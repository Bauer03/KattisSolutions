Creating a new project sets up a main.rs file with a 'hello world' print on it.
If you do cargo run, you'll run your cargo program. Yay.

# What does running the file with cargo do?
Creates a target directory, and creates a 'debug' dir where you finally have your executable file.
There's only one executable in a single project folder (at least, that's been generated by cargo).

##
each program has fn main() {} in it.
What might you want to do?

# Variables
let a = 5; -> Valid rust code. 
but if you try to println(a), you can't do it.

compiler will let you know "hmm, did you mean println("{}", a)"?
or println("{a}");

Rust is a highly typed language, as is well known. 
Rust decided, when you said let a = 5;, that a was an integer.
You can also do this yourself.

let a:i32 = 5;
println!("{a}");

or, a:u32 = 5; // this will just be unsigned, but is valid code still.

f32, for example, would be a float - you have character types, boolean types, integer, etc etc.

let a:u32 = 0o55; // 0o is octal, so 8*5 + 1*5
or let a:0x552 -> hexcode.
or let a:0b010101 -> obvs binary.

let a = ("hello", 5); // this is called a tuple - perfectly valid, called a 'compound type'.
first component is a string, the second component is an integer.

# What happens if we try to print it?
Just doing println!("{a}") won't work.
But, if we put a :? in that, it will! ("{:?a}")

Note that the println only prints strings.

You could do let first = a.0;
println!("{first}");

What about
let a = [1,2,3,4,5]; // in an array, all elements have to be the same type.
let first = a[0];
println!("{first}"); // will print out 1.

# What if we wanted to print the entire array?
well, we'd iterate over it, ideally.

loop {
    println!("{a:?}") // will run indefinitely.
}

but, loop {
    println!("{a:?}");
    break;
}

or 
let first = 0;
while first < 5 {
    println!("{a[first]}"); // this will NOT work
    println!("{}", a[first]) // this will, but ONLY if first is let mut first = 0;
    first += 1;
}

Note that rust scoping is interesting.
{
    let a = 5;
    {
        let a = 6;
        println!("{a}");
    }
    println!("{a}");
} // this prints 6, 5. the a in the innner scope superseded the outer one, but didn't replace it.

Let a = String::from("Hello");
println("{}", a);
let b = "hello"
println("{}", b); you'll see the same thing.
note b is a string, a is an object here.

fn print(t:str) {
    println!("{}",t);
}